% This source file is part of the Geophysical Fluids Modeling Framework (GAME), which is released under the MIT license.
% Github repository: https://github.com/MHBalsmeier/game

\documentclass[10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{a4wide, amsmath, xcolor, longtable, geometry, fancyhdr, mathtools, array, listings}
\usepackage[style = numeric, backend = biber]{biblatex}
\usepackage{fouriernc}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\geometry{a4paper, top = 15mm, left = 5mm, right = 5mm, bottom = 17mm}
\fancypagestyle{plain}{
\fancyhead[L]{\texttt{GAME} handbook}
\fancyhead[R]{\textsc{\texttt{GAME} development team}}
\fancyfoot[C]{\thepage}
\addtolength\footskip{12pt}}
\definecolor{table_green}{rgb}{0, 0.6, 0}
\title{\texttt{Geophysical Fluids Modeling Framework} Handbook}
\author{\texttt{GAME} Development Team}
\newcommand{\md}[1]{\frac{D#1}{Dt}}
\newcommand{\omegabi}{\text{{\osgbi ω}}}
\newcommand{\mubi}{\text{{\osgbi μ}}}
\newcommand{\sigmabi}{\text{{\osgbi σ}}}
\newcommand{\epsilonbi}{\text{{\osgbi ϵ}}}
\newcommand{\etabi}{\text{{\osgbi η}}}
\newcommand{\zetabi}{\text{{\osgbi ζ}}}

\begin{document}

\maketitle

\vspace*{5 cm}
\begin{center}
All physical quantities in this document are to be multiplied with their respective SI units.
\end{center}

\newpage

\tableofcontents

\chapter{Overview}
\label{chap:overview}

This is only the handbook (manual) of the \texttt{Geophysical Fluids Modeling Framework (GAME)}, it explains how to configure, compile and run (use) the model. For a scientific derivation of the model see the documentation and the literature cited therein. The source code of the project is maintained on github (\url{https://github.com/MHBalsmeier/game}), this is also the place to ask questions or report errors. It is never wrong to think a bit before you post something there.

The \texttt{GAME} project incorporates four different executables:

\begin{itemize}
\item \texttt{grid\_generator}, a program for creating model grids
\item \texttt{orography\_generator}, a tool for creating orography files
\item \texttt{test\_generator}, a tool for creating initialization states of test scenarios
\item \texttt{game}, the model executable itself
\end{itemize}

\chapter{Installation}
\label{chap:installation}

\section{Dependencies}
\label{sec:dependencies}

The following dependencies must be installed before being able to successfully build the model:

\begin{itemize}
\item geos95 (\url{https://github.com/MHBalsmeier/geos95})
\item netcdf library (Ubuntu: \texttt{sudo apt-get libnetcdf-dev})
\item eccodes library (installation manual: \url{https://mhbalsmeier.github.io/tutorials/eccodes_on_ubuntu.html})
\item CMake (Ubuntu: \texttt{sudo apt-get install cmake})
\item atmostracers (\url{https://github.com/MHBalsmeier/atmostracers})
\item OpenMPI (Ubuntu: \texttt{sudo apt-get install mpich})

\subsection{For using the plotting routines}
\label{sec:for_using_the_plotting_routines}

The following packages are additionally required if you want to make use of the plotting routines:
%
\item Python and the visualization library scitools-iris (installation manual: \url{https://mhbalsmeier.github.io/tutorials/iris_on_ubuntu.html}, only for the plotting routines, which are of course not art of the actual model)
\item FFMPEG (Ubuntu: \texttt{sudo apt-get install ffmpeg}, only for the plotting routines)

\subsection{For developing}
\label{sec:for_developing}

\item Valgrind (Ubuntu: \texttt{sudo apt-get install valgrind}, for doing checks)
\end{itemize}

\section{Building}
\label{sec:building}

\texttt{CMake} is used for building \texttt{GAME}. The building process is managed using the bash scripts in the directory \texttt{build\_scripts}. The following list gives an overview of the scripts residing in this directory:

\begin{itemize}
\item \texttt{build\_install.sh}: The installation directory is controlled by the variable \texttt{aim\_dir}.
\item \texttt{install\_grids.sh}: Installs the grids to the installation directory.
\item \texttt{install\_tests.sh}: Installs the test state initialization files to the installation directory.
\item \texttt{install\_run\_scripts.sh}: Installs the run scripts to the installation directory.
\item \texttt{install\_plotting\_routines.sh}: Installs the plotting routines to the installation directory.
\item \texttt{install\_everything.sh}: Executes all the other install scripts.
\end{itemize}

Scripts with the suffix \texttt{\_dev} are not different from the original scripts, they only allow choosing a different installation directory for installations of test versions.

\chapter{Running the model}
\label{chap:running_the_model}

The configuration of the model must be set in three different files:

\begin{itemize}
\item \texttt{core/src/enum\_and\_typedefs.h}: modify \texttt{RES\_ID}, \texttt{NO\_OF\_LAYERS} and \texttt{NO\_OF\_ORO\_LAYERS}. These must conform with the grid file and the initialization state file.
\item The file \texttt{core/src/settings.c}: configure  settings that are not accessible via the run scripts. Some quantities in \texttt{core/src/settings.h} will also need to be modified.
\item The run script: one of the files contained in the directory \texttt{run\_scripts}. The comments in these files explain the meaning of the variables.
\end{itemize}
%
Since the files \texttt{core/src/enum\_and\_typedefs.h} and \texttt{core/src/settings.c} are part of the model's source code, the model must be recompiled if something is changed in them. Alternatively, one can compile several executables and name them according to their configuration.

\chapter{Grid generation}
\label{chap:grid_generation}

\section{Horizontal grid properties}
\label{sec:horizontal_grid_properties}

The horizontal grid structure is determined by the following properties:

\begin{itemize}
\item the resolution, specified via the parameter \texttt{RES\_ID}
\item the optimization
\end{itemize}

\section{Vertical grid properties}
\label{sec:vertical_grid_properties}

The vertical grid structure is determined by the following properties:

\begin{itemize}
\item the height of the top of the atmosphere, specified via the parameter \texttt{TOA}
\item the number of layers, specified via the parameter \texttt{NUMBER\_OF\_LAYERS} $N_L$
\item the number of layers following the orography, specified via the parameter \texttt{NUMBER\_OF\_ORO\_LAYERS} $N_O$
\item the stretching parameter $\beta$, which can be set in the run script
\item the orography, specified via the parameter \texttt{ORO\_ID}
\end{itemize}

The generation of the vertical position of the grid points works in three steps:
%
\begin{enumerate}
\item First of all, vertical positions of preliminary levels with index $0 \leq j \leq N_L$ are determined by
%
\begin{align}
z_j = T\sigma_{z, j} + B_jz_S,
\end{align}
%
where $T$ is the top of the atmosphere, $\sigma_{z, j}$ is defined by
%
\begin{align}
\sigma_{z, j} \coloneqq \left(1 - \frac{j}{N_L}\right)^\alpha,
\end{align}
%
where $\alpha \geq 1$ is the so-called \textit{stretching parameter}, $z_s$ is the surface height and $B_j$ is defined by
%
\begin{align}
B_j \coloneqq \frac{j - \left(N_L - N_O\right)}{N_O}.
\end{align}
%
\item Then, the scalar points are positioned in the middle between the adjacent preliminary levels.
\item Then, the vertical vector points are regenerated by placing them in the middle between the two adjacent layers.
\item Finally, the vertical positions of the other points are diagnozed through interpolation.
\end{enumerate}

\section{How to generate a grid}
\label{sec:how_to_generate_a_grid}

The grid generator needs to be recompiled for every specific resolution, top height, number of layers as well as number of orography following layers. Therefore change the respective constants in the file \texttt{grid\_generator.c} and execute the bash script \texttt{compile.sh}. Then run the grid generator using the bash script \texttt{run.sh} with the desired \texttt{\texttt{ORO\_ID}}. Table \ref{tab:grid_generator_run_file_explanation} explains all the parameters to be set in \texttt{run.sh}. Optimized grids have the postfix \texttt{\_SCVT}.

\renewcommand{\arraystretch}{1.2}
\begin{table}
\centering
\begin{tabular}{|>{\centering}p{5.0 cm}|>{\centering}p{3 cm}|>{\centering}p{7 cm}|}
\hline \textbf{name} & \textbf{domain} & \textbf{meaning} \tabularnewline
\hline\hline \texttt{\texttt{ORO\_ID}} & all value for which an orography is defined & orography ID \tabularnewline
\hline\hline \texttt{optimize} & 0, 1 & optimization switch (fails if \texttt{\texttt{ORO\_ID}} is not 0) \tabularnewline
\hline\hline \texttt{n\_iterations} & integer $\geq$ 1 & number of iterations (ignored if \texttt{optimize} = 0), 2000 seems to be a safe value \tabularnewline
\hline\hline \texttt{use\_scalar\_h\_coords\_file} & 0, 1 & switch to determine wether horizontal coordinates of triangle vertices (generators of the grid) shall be used from another file \tabularnewline
\hline\hline \texttt{scalar\_h\_coords\_file} & string & input file for dual triangle vertices (only relevant if \texttt{use\_scalar\_h\_coords\_file} = 1) \tabularnewline
\hline\hline \texttt{stretching\_parameter} & $\geq$ 1, real & defines the vertical stretching of the grid, one means no stretching \tabularnewline
\hline
\end{tabular}
\caption{Grid generator run script explanation.}
\label{tab:grid_generator_run_file_explanation}
\end{table}
\renewcommand{\arraystretch}{1}

\chapter{Generating a new orography file}
\label{chap:generating_a_new_orography_file}

\renewcommand{\arraystretch}{1.2}
\begin{table}
\centering
\begin{tabular}{|>{\centering}p{4.0 cm}|>{\centering}p{8 cm}|}
\hline \textbf{\texttt{ORO\_ID}} & \textbf{Description} \tabularnewline
\hline\hline 0 & no orography \tabularnewline
\hline 1 & orography of JW test \tabularnewline
\hline 2 & Gaussian mountain of 8 km height and 224 m standard deviation located ad 0 N / 0 E\tabularnewline
\hline $\geq$ 3 & real orography \tabularnewline
\hline
\end{tabular}
\caption{Definition of orography IDs.}
\label{tab:oro_id_definition}
\end{table}
\renewcommand{\arraystretch}{1}

Orography files are generated with the code residing in the directory \texttt{orography\_generator/src}. Firstly, change the parameter \texttt{RES\_ID} in the file \texttt{orography\_generator.c} to the desired value and compile. Then source the bash scribt \texttt{run.sh} with the desired \texttt{\texttt{ORO\_ID}}. Tab. \ref{tab:oro_id_definition} shows the definition of the orography IDs. Real orography can be downloaded from
%
\begin{itemize}
\item \texttt{https://psl.noaa.gov/cgi-bin/db\_search/DBSearch.pl?Dataset=NCEP+Reanalysis\\\&Variable=Geopotential+height\&group=0\&submit=Search} (\texttt{ORO\_ID} = 3)
\end{itemize}
%
These files are stored in the directory \texttt{orography\_generator/real}. An information file explains them and defines their individual \texttt{ORO\_ID}s. A $1/r$-interpolation with four values is used to interpolate the data to the scalar data points.

\chapter{Generating a new test state file}
\label{chap:generating_a_new_test_state_file}

\renewcommand{\arraystretch}{1.2}
\begin{table}
\centering
\begin{tabular}{|>{\centering}p{4.0 cm}|>{\centering}p{8 cm}|}
\hline \textbf{\texttt{TEST\_ID}} & \textbf{Description} \tabularnewline
\hline\hline 0 & standard atmosphere \tabularnewline
\hline 1 & standard atmosphere with Gaussian mountain (\texttt{ORO\_ID} = 2) \tabularnewline
\hline 2 & JW dry unperturbed \tabularnewline
\hline 3 & JW dry perturbed \tabularnewline
\hline 4 & JW moist unperturbed \tabularnewline
\hline 5 & JW moist perturbed \tabularnewline
\hline 6 & JW dry, balanced, with \texttt{ORO\_ID} = 3 \tabularnewline
\hline 7 & JW moist, balanced, with \texttt{ORO\_ID} = 3 \tabularnewline
\hline 8 & Ullrich dry \tabularnewline
\hline 9 & Ullrich moist \tabularnewline
\hline 10 & Ullrich dry with \texttt{ORO\_ID} = 3 \tabularnewline
\hline 11 & Ullrich moist with \texttt{ORO\_ID} = 3 \tabularnewline
\hline 12 & standard atmosphere \texttt{ORO\_ID} = 3 \tabularnewline
\hline
\end{tabular}
\caption{Definition of test IDs.}
\label{tab:test_id_definition}
\end{table}
\renewcommand{\arraystretch}{1}

A new test state can be generated with the code in the directory \texttt{test\_generator/src}. Therefore, firstly change the parameters \texttt{RES\_ID}, \texttt{NUMBER\_OF\_LAYERS} and \texttt{NUMBER\_OF\_ORO\_LAYERS} in the file \texttt{test\_generator.c}. Then compile by sourcing the file \texttt{compile.sh} before executing the file \texttt{run.sh} with the specific \texttt{test\_id}. Tab. \ref{tab:test_id_definition} shows the definition of the test IDs.

\end{document}













